{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useCallback, useEffect, useReducer, useRef } from \"react\";\nimport { OrderFeedActionType, OrderFeedType, WebSocketReadyState, Product, OrderFeedEvent } from \"../types\";\nimport { useErrorHandler } from \"react-error-boundary\";\nimport { OrderFeedReducer } from \"../components/orderFeed/OrderFeedReducer\";\nimport { applyOrderDataDelta } from \"../utils/utils\";\nconst initialState = {\n  bids: {},\n  asks: {},\n  productFeedSubscription: Product.XBTUSD\n};\n\n/**\n * connects to a (currently hardcoded) WebSocket server. Upon established connection,\n * sends a (currently hardcoded) subscription message with a paramaterized product_id.\n *\n * incoming snapshot messages are dispatched immediately, but incoming delta messages\n * are reduced & stored into a ref buffer. the buffer is dispatched every (currently hardcoded)\n * 250ms.\n *\n * if the productFeedSubscription falls out of sync with the local state, useOrderFeed will\n * unsubscribe from the subscription in the local state, and subscribe to the product feed\n * from productFeedSubscription, and then dispatch an action to sync up the local state.\n *\n * closes the websocket connection when calling component is unmounted.\n *\n * @param productFeedSubscription desired product feed to subscribe to\n * @param forceErrorFlag contrived flag that forces an Error to be thrown when set\n * @returns\n */\nexport function useOrderFeed({\n  productFeedSubscription = Product.XBTUSD,\n  forceErrorFlag = false\n} = {}) {\n  _s();\n\n  const [state, dispatch] = useReducer(OrderFeedReducer, { ...initialState,\n    productFeedSubscription\n  });\n  const webSocket = useRef(null);\n  const bufferedData = useRef({\n    bids: {},\n    asks: {}\n  });\n  const handleError = useErrorHandler();\n  /**\n   * this function is called on every incoming websocket message.\n   * snapshots are dispatched right away. deltas are calculated and\n   * stored in a ref buffer until a setInterval dispatches them\n   * every so often. this is to keep the render load steady despite\n   * the frequency of the incoming websocket messages\n   */\n\n  const onMessage = useCallback(messageEvent => {\n    const response = JSON.parse(messageEvent === null || messageEvent === void 0 ? void 0 : messageEvent.data);\n\n    switch (response === null || response === void 0 ? void 0 : response.feed) {\n      case OrderFeedType.Delta:\n        bufferedData.current.bids = applyOrderDataDelta(bufferedData.current.bids, response.bids);\n        bufferedData.current.asks = applyOrderDataDelta(bufferedData.current.asks, response.asks);\n        break;\n\n      case OrderFeedType.Snapshot:\n        bufferedData.current.bids = applyOrderDataDelta({}, response.bids);\n        bufferedData.current.asks = applyOrderDataDelta({}, response.asks);\n        dispatch({\n          type: OrderFeedActionType.ApplyDelta,\n          payload: {\n            bids: bufferedData.current.bids,\n            asks: bufferedData.current.asks\n          }\n        });\n        break;\n    }\n  }, [dispatch]);\n  /**\n   * this useEffect simply dispatches the current buffered data\n   * every 250ms. it also has a cleanup callback function to\n   * clear the interval as well as ensure the websocket is closed\n   * when the calling component unmounts.\n   */\n\n  useEffect(() => {\n    const bufferInterval = setInterval(() => {\n      dispatch({\n        type: OrderFeedActionType.ApplyDelta,\n        payload: {\n          asks: bufferedData.current.asks,\n          bids: bufferedData.current.bids\n        }\n      });\n    }, 250);\n    return () => {\n      var _webSocket$current;\n\n      clearInterval(bufferInterval);\n      webSocket === null || webSocket === void 0 ? void 0 : (_webSocket$current = webSocket.current) === null || _webSocket$current === void 0 ? void 0 : _webSocket$current.close();\n    };\n  }, []);\n  /**\n   * handleError() is required here because Error Boundaries do not catch errors for\n   * event handlers by default, so a simple `throw` won't work.\n   * https://reactjs.org/docs/error-boundaries.html#introducing-error-boundaries\n   */\n\n  const onError = useCallback(ev => {\n    handleError(new Error(`WebSocket threw an error. Please reset the feed.`));\n  }, [handleError]);\n  const onOpen = useCallback(() => {\n    subscribeToProductOrderFeed(state.productFeedSubscription);\n  }, [state.productFeedSubscription]);\n  /**\n   * this useEffect is responsible for opening the websocket connection\n   * when the calling component mounts.\n   *\n   * it also serves as the spot where the contrived forced error throws\n   * the error.\n   */\n\n  useEffect(() => {\n    if (forceErrorFlag) {\n      throw new Error(\"An error was forced from within the WebSocket handling code.\");\n    }\n\n    if (!webSocket.current || webSocket.current.readyState === WebSocketReadyState.CLOSING || webSocket.current.readyState === WebSocketReadyState.CLOSED) {\n      webSocket.current = new WebSocket(\"wss://www.cryptofacilities.com/ws/v1\");\n      webSocket.current.onopen = onOpen;\n      webSocket.current.onmessage = onMessage;\n      webSocket.current.onerror = onError;\n    }\n  }, [forceErrorFlag, onError, onMessage, onOpen]);\n  /**\n   * this useEffect is responsible for changing subscriptions. if the\n   * productFeedSubscription parameter from the calling component falls\n   * out of sync with this hook's state.productFeedSubscription, this useEffect\n   * will unsubscribe to the feed in state.productFeedSubscription, and then\n   * subscribe to the feed in productFeedSubscription. it will then dispatch to\n   * sync back up.\n   */\n\n  useEffect(() => {\n    if (webSocket.current && webSocket.current.readyState === WebSocketReadyState.OPEN && productFeedSubscription !== state.productFeedSubscription) {\n      unsubscribeFromProductOrderFeed(state.productFeedSubscription);\n      subscribeToProductOrderFeed(productFeedSubscription);\n      dispatch({\n        type: OrderFeedActionType.ChangeSubscription,\n        payload: {\n          subscription: productFeedSubscription\n        }\n      });\n    }\n  }, [productFeedSubscription, state.productFeedSubscription]);\n\n  function subscribeToProductOrderFeed(subscription) {\n    var _webSocket$current2;\n\n    webSocket === null || webSocket === void 0 ? void 0 : (_webSocket$current2 = webSocket.current) === null || _webSocket$current2 === void 0 ? void 0 : _webSocket$current2.send(JSON.stringify({\n      event: OrderFeedEvent.Subscribe,\n      feed: OrderFeedType.Delta,\n      product_ids: [subscription]\n    }));\n  }\n\n  function unsubscribeFromProductOrderFeed(subscription) {\n    var _webSocket$current3;\n\n    webSocket === null || webSocket === void 0 ? void 0 : (_webSocket$current3 = webSocket.current) === null || _webSocket$current3 === void 0 ? void 0 : _webSocket$current3.send(JSON.stringify({\n      event: OrderFeedEvent.Unsubscribe,\n      feed: OrderFeedType.Delta,\n      product_ids: [subscription]\n    }));\n  }\n\n  return { ...state\n  };\n}\n\n_s(useOrderFeed, \"LQ7ilhrq7Swnc/kH5IY7bxsCXaE=\", false, function () {\n  return [useErrorHandler];\n});","map":{"version":3,"sources":["/Users/ferni/Ferni/fernando-10-08-21/src/hooks/useOrderFeed.tsx"],"names":["useCallback","useEffect","useReducer","useRef","OrderFeedActionType","OrderFeedType","WebSocketReadyState","Product","OrderFeedEvent","useErrorHandler","OrderFeedReducer","applyOrderDataDelta","initialState","bids","asks","productFeedSubscription","XBTUSD","useOrderFeed","forceErrorFlag","state","dispatch","webSocket","bufferedData","handleError","onMessage","messageEvent","response","JSON","parse","data","feed","Delta","current","Snapshot","type","ApplyDelta","payload","bufferInterval","setInterval","clearInterval","close","onError","ev","Error","onOpen","subscribeToProductOrderFeed","readyState","CLOSING","CLOSED","WebSocket","onopen","onmessage","onerror","OPEN","unsubscribeFromProductOrderFeed","ChangeSubscription","subscription","send","stringify","event","Subscribe","product_ids","Unsubscribe"],"mappings":"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","sourcesContent":["import { useCallback, useEffect, useReducer, useRef } from \"react\";\nimport {\n  OrderFeedActionType,\n  OrderFeedMessage,\n  OrderFeedType,\n  WebSocketReadyState,\n  Product,\n  OrderFeedState,\n  OrderFeedEvent,\n  OrderData,\n} from \"../types\";\nimport { useErrorHandler } from \"react-error-boundary\";\nimport { OrderFeedReducer } from \"../components/orderFeed/OrderFeedReducer\";\nimport { applyOrderDataDelta } from \"../utils/utils\";\n\nconst initialState: OrderFeedState = {\n  bids: {},\n  asks: {},\n  productFeedSubscription: Product.XBTUSD,\n};\n\ntype BufferData = {\n  bids: OrderData;\n  asks: OrderData;\n};\n\n/**\n * connects to a (currently hardcoded) WebSocket server. Upon established connection,\n * sends a (currently hardcoded) subscription message with a paramaterized product_id.\n *\n * incoming snapshot messages are dispatched immediately, but incoming delta messages\n * are reduced & stored into a ref buffer. the buffer is dispatched every (currently hardcoded)\n * 250ms.\n *\n * if the productFeedSubscription falls out of sync with the local state, useOrderFeed will\n * unsubscribe from the subscription in the local state, and subscribe to the product feed\n * from productFeedSubscription, and then dispatch an action to sync up the local state.\n *\n * closes the websocket connection when calling component is unmounted.\n *\n * @param productFeedSubscription desired product feed to subscribe to\n * @param forceErrorFlag contrived flag that forces an Error to be thrown when set\n * @returns\n */\nexport function useOrderFeed({\n  productFeedSubscription = Product.XBTUSD,\n  forceErrorFlag = false,\n}: UseOrderFeedProps = {}): OrderFeedState {\n  const [state, dispatch] = useReducer(OrderFeedReducer, {\n    ...initialState,\n    productFeedSubscription,\n  });\n  const webSocket = useRef<WebSocket | null>(null);\n  const bufferedData = useRef<BufferData>({ bids: {}, asks: {} });\n  const handleError = useErrorHandler();\n\n  /**\n   * this function is called on every incoming websocket message.\n   * snapshots are dispatched right away. deltas are calculated and\n   * stored in a ref buffer until a setInterval dispatches them\n   * every so often. this is to keep the render load steady despite\n   * the frequency of the incoming websocket messages\n   */\n  const onMessage = useCallback(\n    (messageEvent: MessageEvent) => {\n      const response = JSON.parse(messageEvent?.data) as OrderFeedMessage;\n      switch (response?.feed) {\n        case OrderFeedType.Delta:\n          bufferedData.current.bids = applyOrderDataDelta(\n            bufferedData.current.bids,\n            response.bids\n          );\n          bufferedData.current.asks = applyOrderDataDelta(\n            bufferedData.current.asks,\n            response.asks\n          );\n          break;\n        case OrderFeedType.Snapshot:\n          bufferedData.current.bids = applyOrderDataDelta({}, response.bids);\n          bufferedData.current.asks = applyOrderDataDelta({}, response.asks);\n          dispatch({\n            type: OrderFeedActionType.ApplyDelta,\n            payload: {\n              bids: bufferedData.current.bids,\n              asks: bufferedData.current.asks,\n            },\n          });\n          break;\n      }\n    },\n    [dispatch]\n  );\n\n  /**\n   * this useEffect simply dispatches the current buffered data\n   * every 250ms. it also has a cleanup callback function to\n   * clear the interval as well as ensure the websocket is closed\n   * when the calling component unmounts.\n   */\n  useEffect(() => {\n    const bufferInterval = setInterval(() => {\n      dispatch({\n        type: OrderFeedActionType.ApplyDelta,\n        payload: {\n          asks: bufferedData.current.asks,\n          bids: bufferedData.current.bids,\n        },\n      });\n    }, 250);\n\n    return () => {\n      clearInterval(bufferInterval);\n      webSocket?.current?.close();\n    };\n  }, []);\n\n  /**\n   * handleError() is required here because Error Boundaries do not catch errors for\n   * event handlers by default, so a simple `throw` won't work.\n   * https://reactjs.org/docs/error-boundaries.html#introducing-error-boundaries\n   */\n  const onError = useCallback(\n    (ev: Event) => {\n      handleError(\n        new Error(`WebSocket threw an error. Please reset the feed.`)\n      );\n    },\n    [handleError]\n  );\n\n  const onOpen = useCallback(() => {\n    subscribeToProductOrderFeed(state.productFeedSubscription);\n  }, [state.productFeedSubscription]);\n\n  /**\n   * this useEffect is responsible for opening the websocket connection\n   * when the calling component mounts.\n   *\n   * it also serves as the spot where the contrived forced error throws\n   * the error.\n   */\n  useEffect(() => {\n    if (forceErrorFlag) {\n      throw new Error(\n        \"An error was forced from within the WebSocket handling code.\"\n      );\n    }\n\n    if (\n      !webSocket.current ||\n      webSocket.current.readyState === WebSocketReadyState.CLOSING ||\n      webSocket.current.readyState === WebSocketReadyState.CLOSED\n    ) {\n      webSocket.current = new WebSocket(\"wss://www.cryptofacilities.com/ws/v1\");\n      webSocket.current.onopen = onOpen;\n      webSocket.current.onmessage = onMessage;\n      webSocket.current.onerror = onError;\n    }\n  }, [forceErrorFlag, onError, onMessage, onOpen]);\n\n  /**\n   * this useEffect is responsible for changing subscriptions. if the\n   * productFeedSubscription parameter from the calling component falls\n   * out of sync with this hook's state.productFeedSubscription, this useEffect\n   * will unsubscribe to the feed in state.productFeedSubscription, and then\n   * subscribe to the feed in productFeedSubscription. it will then dispatch to\n   * sync back up.\n   */\n  useEffect(() => {\n    if (\n      webSocket.current &&\n      webSocket.current.readyState === WebSocketReadyState.OPEN &&\n      productFeedSubscription !== state.productFeedSubscription\n    ) {\n      unsubscribeFromProductOrderFeed(state.productFeedSubscription);\n      subscribeToProductOrderFeed(productFeedSubscription);\n      dispatch({\n        type: OrderFeedActionType.ChangeSubscription,\n        payload: {\n          subscription: productFeedSubscription,\n        },\n      });\n    }\n  }, [productFeedSubscription, state.productFeedSubscription]);\n\n  function subscribeToProductOrderFeed(subscription: Product) {\n    webSocket?.current?.send(\n      JSON.stringify({\n        event: OrderFeedEvent.Subscribe,\n        feed: OrderFeedType.Delta,\n        product_ids: [subscription],\n      })\n    );\n  }\n\n  function unsubscribeFromProductOrderFeed(subscription: Product) {\n    webSocket?.current?.send(\n      JSON.stringify({\n        event: OrderFeedEvent.Unsubscribe,\n        feed: OrderFeedType.Delta,\n        product_ids: [subscription],\n      })\n    );\n  }\n\n  return {\n    ...state,\n  };\n}\n\nexport type UseOrderFeedProps = {\n  productFeedSubscription?: Product;\n  forceErrorFlag?: boolean;\n};\n"]},"metadata":{},"sourceType":"module"}