{"ast":null,"code":"export function groupAndTotalOrders(orderData, grouping, returnReversed = false, returnSize = 17) {\n  const orderDataValues = Object.values(orderData);\n  const groupedOrders = orderDataValues.reduce((groupedOrders, currentOrder) => {\n    /**\n     * the more precise prices for ETH are victim to binary divison,\n     * we need to normalize to integers in order to group first, then\n     * we can divide by 100 after to get back the price without rounding\n     * errors. this assumes prices are at most 2 decimal places.\n     */\n    const groupingAsInteger = grouping * 100;\n    const price = Math.round(currentOrder.price * 100);\n    const remainder = price % groupingAsInteger;\n    let priceBucket = (price - remainder) / 100; //since orderData's properties are sorted ascending due to integer keys, we can build up the new array in order\n\n    if (groupedOrders.length === 0) {\n      groupedOrders.push({\n        price: priceBucket,\n        size: currentOrder.size,\n        total: 0\n      });\n      return groupedOrders;\n    } //if the last bucket is for the same price, we can simply add to the size\n    //i.e. we just pushed {price: 50}, and currentOrder has {price:50}\n\n\n    const lastBucket = groupedOrders[groupedOrders.length - 1];\n\n    if (lastBucket.price === priceBucket) {\n      lastBucket.size += currentOrder.size;\n    } else {\n      //we don't need to look for a matching price bucket since orderData is sorted ascending.\n      //this is guaranteed to be a new price bucket now, so simply push()\n      groupedOrders.push({\n        price: priceBucket,\n        size: currentOrder.size,\n        total: 0\n      });\n    }\n\n    return groupedOrders;\n  }, []); //slice before reversing for a slight performance boost. however a discussion with\n  //the product owner would be required to determine what parts of the data should be\n  //shown, as the slice/reverse order as well as what end to slice from changes the data shown.\n\n  const slicedGroupedOrders = groupedOrders.slice(0, returnSize);\n\n  if (returnReversed) {\n    slicedGroupedOrders.reverse();\n  }\n\n  let total = 0;\n  slicedGroupedOrders.forEach((order, i) => {\n    slicedGroupedOrders[i].total = total += order.size;\n  });\n  return slicedGroupedOrders;\n}\nexport function applyOrderDataDelta(currentOrderData, orderDataDelta) {\n  if (!orderDataDelta) {\n    return currentOrderData;\n  }\n\n  const nextOrdersState = { ...currentOrderData\n  };\n  orderDataDelta.forEach(order => {\n    const [price, size] = order;\n    /**\n     * using Math.round(price * 100) as the key is a trick which gives\n     * the benefit of a pseudo insertion sort due to how properties are\n     * sorted on objects from ECMAScript 2015 and later. it is insertion\n     * order for string keys and symbols, but ascending order for integer keys\n     * this code assumes that the price is only 2 decimal places at most\n     * otherwise we could get collisions\n     */\n\n    const integerKey = Math.round(price * 100);\n\n    if (size === 0) {\n      delete nextOrdersState[integerKey];\n    } else {\n      nextOrdersState[integerKey] = {\n        price,\n        size\n      };\n    }\n  });\n  return nextOrdersState;\n}","map":{"version":3,"sources":["/Users/ferni/Ferni/fernando-10-08-21/src/utils/utils.tsx"],"names":["groupAndTotalOrders","orderData","grouping","returnReversed","returnSize","orderDataValues","Object","values","groupedOrders","reduce","currentOrder","groupingAsInteger","price","Math","round","remainder","priceBucket","length","push","size","total","lastBucket","slicedGroupedOrders","slice","reverse","forEach","order","i","applyOrderDataDelta","currentOrderData","orderDataDelta","nextOrdersState","integerKey"],"mappings":"AAQA,OAAO,SAASA,mBAAT,CACLC,SADK,EAELC,QAFK,EAGLC,cAAuB,GAAG,KAHrB,EAILC,UAAkB,GAAG,EAJhB,EAKa;AAClB,QAAMC,eAAe,GAAGC,MAAM,CAACC,MAAP,CAAcN,SAAd,CAAxB;AAEA,QAAMO,aAAa,GAAGH,eAAe,CAACI,MAAhB,CACpB,CACED,aADF,EAEEE,YAFF,KAGuB;AACrB;AACN;AACA;AACA;AACA;AACA;AACM,UAAMC,iBAAiB,GAAGT,QAAQ,GAAG,GAArC;AACA,UAAMU,KAAK,GAAGC,IAAI,CAACC,KAAL,CAAWJ,YAAY,CAACE,KAAb,GAAqB,GAAhC,CAAd;AACA,UAAMG,SAAS,GAAGH,KAAK,GAAGD,iBAA1B;AACA,QAAIK,WAAW,GAAG,CAACJ,KAAK,GAAGG,SAAT,IAAsB,GAAxC,CAVqB,CAYrB;;AACA,QAAIP,aAAa,CAACS,MAAd,KAAyB,CAA7B,EAAgC;AAC9BT,MAAAA,aAAa,CAACU,IAAd,CAAmB;AACjBN,QAAAA,KAAK,EAAEI,WADU;AAEjBG,QAAAA,IAAI,EAAET,YAAY,CAACS,IAFF;AAGjBC,QAAAA,KAAK,EAAE;AAHU,OAAnB;AAKA,aAAOZ,aAAP;AACD,KApBoB,CAsBrB;AACA;;;AACA,UAAMa,UAAU,GAAGb,aAAa,CAACA,aAAa,CAACS,MAAd,GAAuB,CAAxB,CAAhC;;AACA,QAAII,UAAU,CAACT,KAAX,KAAqBI,WAAzB,EAAsC;AACpCK,MAAAA,UAAU,CAACF,IAAX,IAAmBT,YAAY,CAACS,IAAhC;AACD,KAFD,MAEO;AACL;AACA;AACAX,MAAAA,aAAa,CAACU,IAAd,CAAmB;AACjBN,QAAAA,KAAK,EAAEI,WADU;AAEjBG,QAAAA,IAAI,EAAET,YAAY,CAACS,IAFF;AAGjBC,QAAAA,KAAK,EAAE;AAHU,OAAnB;AAKD;;AAED,WAAOZ,aAAP;AACD,GA1CmB,EA2CpB,EA3CoB,CAAtB,CAHkB,CAiDlB;AACA;AACA;;AACA,QAAMc,mBAAmB,GAAGd,aAAa,CAACe,KAAd,CAAoB,CAApB,EAAuBnB,UAAvB,CAA5B;;AAEA,MAAID,cAAJ,EAAoB;AAClBmB,IAAAA,mBAAmB,CAACE,OAApB;AACD;;AAED,MAAIJ,KAAK,GAAG,CAAZ;AACAE,EAAAA,mBAAmB,CAACG,OAApB,CAA4B,CAACC,KAAD,EAAQC,CAAR,KAAc;AACxCL,IAAAA,mBAAmB,CAACK,CAAD,CAAnB,CAAuBP,KAAvB,GAA+BA,KAAK,IAAIM,KAAK,CAACP,IAA9C;AACD,GAFD;AAIA,SAAOG,mBAAP;AACD;AAED,OAAO,SAASM,mBAAT,CACLC,gBADK,EAELC,cAFK,EAGM;AACX,MAAI,CAACA,cAAL,EAAqB;AACnB,WAAOD,gBAAP;AACD;;AAED,QAAME,eAAe,GAAG,EAAE,GAAGF;AAAL,GAAxB;AAEAC,EAAAA,cAAc,CAACL,OAAf,CAAwBC,KAAD,IAAW;AAChC,UAAM,CAACd,KAAD,EAAQO,IAAR,IAAgBO,KAAtB;AAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AACI,UAAMM,UAAU,GAAGnB,IAAI,CAACC,KAAL,CAAWF,KAAK,GAAG,GAAnB,CAAnB;;AACA,QAAIO,IAAI,KAAK,CAAb,EAAgB;AACd,aAAOY,eAAe,CAACC,UAAD,CAAtB;AACD,KAFD,MAEO;AACLD,MAAAA,eAAe,CAACC,UAAD,CAAf,GAA8B;AAAEpB,QAAAA,KAAF;AAASO,QAAAA;AAAT,OAA9B;AACD;AACF,GAjBD;AAmBA,SAAOY,eAAP;AACD","sourcesContent":["import {\n  UsdDenomination,\n  Order,\n  OrderData,\n  OrderFeedPriceBucket,\n  OrderWithTotal,\n} from \"../types\";\n\nexport function groupAndTotalOrders(\n  orderData: OrderData,\n  grouping: UsdDenomination,\n  returnReversed: boolean = false,\n  returnSize: number = 17\n): OrderWithTotal[] {\n  const orderDataValues = Object.values(orderData);\n\n  const groupedOrders = orderDataValues.reduce(\n    (\n      groupedOrders: OrderWithTotal[],\n      currentOrder: Order\n    ): OrderWithTotal[] => {\n      /**\n       * the more precise prices for ETH are victim to binary divison,\n       * we need to normalize to integers in order to group first, then\n       * we can divide by 100 after to get back the price without rounding\n       * errors. this assumes prices are at most 2 decimal places.\n       */\n      const groupingAsInteger = grouping * 100;\n      const price = Math.round(currentOrder.price * 100);\n      const remainder = price % groupingAsInteger;\n      let priceBucket = (price - remainder) / 100;\n\n      //since orderData's properties are sorted ascending due to integer keys, we can build up the new array in order\n      if (groupedOrders.length === 0) {\n        groupedOrders.push({\n          price: priceBucket,\n          size: currentOrder.size,\n          total: 0,\n        });\n        return groupedOrders;\n      }\n\n      //if the last bucket is for the same price, we can simply add to the size\n      //i.e. we just pushed {price: 50}, and currentOrder has {price:50}\n      const lastBucket = groupedOrders[groupedOrders.length - 1];\n      if (lastBucket.price === priceBucket) {\n        lastBucket.size += currentOrder.size;\n      } else {\n        //we don't need to look for a matching price bucket since orderData is sorted ascending.\n        //this is guaranteed to be a new price bucket now, so simply push()\n        groupedOrders.push({\n          price: priceBucket,\n          size: currentOrder.size,\n          total: 0,\n        });\n      }\n\n      return groupedOrders;\n    },\n    [] as OrderWithTotal[]\n  );\n\n  //slice before reversing for a slight performance boost. however a discussion with\n  //the product owner would be required to determine what parts of the data should be\n  //shown, as the slice/reverse order as well as what end to slice from changes the data shown.\n  const slicedGroupedOrders = groupedOrders.slice(0, returnSize);\n\n  if (returnReversed) {\n    slicedGroupedOrders.reverse();\n  }\n\n  let total = 0;\n  slicedGroupedOrders.forEach((order, i) => {\n    slicedGroupedOrders[i].total = total += order.size;\n  });\n\n  return slicedGroupedOrders;\n}\n\nexport function applyOrderDataDelta(\n  currentOrderData: OrderData,\n  orderDataDelta: OrderFeedPriceBucket[]\n): OrderData {\n  if (!orderDataDelta) {\n    return currentOrderData;\n  }\n\n  const nextOrdersState = { ...currentOrderData };\n\n  orderDataDelta.forEach((order) => {\n    const [price, size] = order;\n\n    /**\n     * using Math.round(price * 100) as the key is a trick which gives\n     * the benefit of a pseudo insertion sort due to how properties are\n     * sorted on objects from ECMAScript 2015 and later. it is insertion\n     * order for string keys and symbols, but ascending order for integer keys\n     * this code assumes that the price is only 2 decimal places at most\n     * otherwise we could get collisions\n     */\n    const integerKey = Math.round(price * 100);\n    if (size === 0) {\n      delete nextOrdersState[integerKey];\n    } else {\n      nextOrdersState[integerKey] = { price, size };\n    }\n  });\n\n  return nextOrdersState;\n}\n"]},"metadata":{},"sourceType":"module"}